\section{Terminology}

\subsection{Language nomenclature}
\label{sec:nomenclature}
Regular expression languages are systems for specifying sets of strings.  There are many regular expression language \emph{variants} with substantially different behavior, and so the term \emph{regular expression} can only refer to the topic in general.  An appropriate prefix must always be added in order to refer to a particular variant (eg. Python Regular Expressions can describe a context free language, but Kleene Regular Expressions cannot).  Note that it is grammatically correct to capitalize these proper nouns because they refer to languages.

Each variant uses several features to specify sets of strings in a compact manner.  A \emph{pattern} is a string that is parsed according to the feature syntax of a variant into units of meaning called \emph{tokens}.  A sequence of feature tokens that is valid in a particular variant will always define a set of strings.  This sequence of feature tokens will be called a \emph{regex} (regexes will be the plural form).

Regexes are commonly used to extend keyword search - instead of searching some text for a single keyword, the user can search that text for any string in the set specified by the regex.   An \emph{engine} implements the rules of a variant in order to perform searching, replacing and other functions within a computing environment.  A single variant may have zero or more engines written for it.  An engine \emph{compiles} a pattern into a regex.  The behavior of an engine may be modified by flags or options, as described in Section\todoMid{N}.

\subsection{Matching strings defined}
\label{sec:matchingDefined}
In this thesis it is often necessary to describe the outcome of searching a particular string using a particular regex.  The terminology used is that a regex \emph{matches} a string if that string contains some substring that is equal to a string specified by the regex.  For example, the regex \cverb!abc! matches the entire string \verb!"abc"! but also matches part of \verb!"XabcY"!, and so the regex matches both strings.  This regex does not match \verb!"ab"! because no \verb!`c'! is present.  When considering if a regex matches a string, it is assumed that no flags are modifying the behavior of the engine unless specified in the regex itself.  For ease of expression, a string is said to \emph{match} a regex if that regex matches the string.

This choice of terminology results in the most natural flow of words when discussing the behavior of regexes, but conflicts with the terminology used by several engines.  For example, Java's {\tt java.util.regex.Matcher.matches()} function requires the entire string to match in order to return true.  Also, Python's {\tt re.match()} function requires the beginning of the string to match in order to regurn a {\tt MatchObject}.  Instead, our definition of \emph{match} is closer to Java's {\tt java.util.regex.Matcher.find()} function and Python's {\tt re.search()} function.  The definition of \emph{match} used in this thesis is useful because, in general, it is a necessary condition (but not always a sufficient condition) for a regex to \emph{match} a string in order for some function provided by an engine to take action based on the match.

\subsection{Patterns are not regexes}
A particular pattern can specify different regexes in different variants.  For example, the pattern \verb!"a\{2\}"! specifies the regex \cverb!a{2}! in BRE Regular Expressions (which matches the string \verb!"aa"!), but in Python Regular Expressions the same pattern compiles to the regex \cverb!a\{2\}! which matches the string \verb!"a{2}"!.
It is also possible for a pattern to be valid and compile to a regex in one variant, but be invalid in another.  For example the pattern \verb!"^X(?R)?O$"! compiles to a valid regex in Perl 5.10 that uses recursion to require one or more \verb!`X'! characters followed by exactly the same number of \verb!`O'! characters, so that the string \verb!"XXOO"! will match, but \verb!"XXO"! will not match.  Trying to compile this pattern in Python will cause an error.

\paragraph{Most patterns compile to a functionally identical regex in most languages}
\label{sec:usuallyOk} Examples have been shown of patterns that have alternate meanings depending on the regular expression language, and patterns that can be compiled by one engine, but not another.  However, it is typical for a pattern using common features to compile to a regex with identical behavior in different regular expression languages.  The extent of feature variation among languages is a difficult subject to approach, and so it is difficult to quantify how often this occurs.  It is likely that many programmers not well versed in the nuances of regular expressions believe that all patterns can be used with identical effects in all languages.  An attempt to document what features are supported by what languages is provided in Section~\ref{sec:featureSupport}.

% \subsection{Regular languages }

% we can have the regex \verb!`(ab*)\1'! which cannot be defined by any finite automata
% (think pumping lemma) and is therefore not a regular language, but is a context-free language
%  and can be recognized by a push-down automata.

% the regex \verb!`(ab*)\1\1'! cannot be defined by any push-down automata
% and is therefore a context-sensitive language\footurl{http://stackoverflow.com/questions/11101405/how-do-backreferences-in-regexes-make-backtracking-required}.

% And while we're on this topic, we should cover languages like $\{<div>^n</div>^n\| n\geq0\}$ which require balanced tags, parenthesis or similar - these cannot be represented with the regex features analyzed in this thesis, but are easily described using Perl 5.10 recursion.








