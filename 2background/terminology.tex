\section{Terminology}

\subsection{Matching strings defined}
\label{sec:matchingDefined}
In this thesis it is often necessary to describe the outcome of searching a particular string using a particular regex.  The terminology used is that a regex \emph{matches} a string if that string contains some substring that is equal to a string specified by the regex.  For example, the regex \cverb!abc! matches the entire string \verb!"abc"! but also matches part of \verb!"XabcY"!, and so the regex matches both strings.  This regex does not match \verb!"ab"! because no \verb!`c'! is present.  When considering if a regex matches a string, it is assumed that no flags are modifying the behavior of the engine unless specified in the regex itself.  For ease of expression, a string is said to \emph{match} a regex if that regex matches the string.

This choice of terminology results in the most natural flow of words when discussing the behavior of regexes, but conflicts with the terminology used by several engines.  For example, Java's {\tt java.util.regex.Matcher.matches()} function requires the entire string to match in order to return true.  Also, Python's {\tt re.match()} function requires the beginning of the string to match in order to return a {\tt MatchObject}.  Instead, the definition of \emph{match} used in this thesis is closer to Java's {\tt java.util.regex.Matcher.find()} function and Python's {\tt re.search()} function.  The definition of \emph{match} used in this thesis is useful because, in general, it is a necessary condition (but not always a sufficient condition) for a regex to \emph{match} a string in order for any function provided by any engine to take action based on that match.

\subsection{Regex support in language differs}
\label{sec:usuallyOk}
It is typical for a pattern using common features to compile to a regex with identical behavior in multiple variants.  The extent of feature overlap among variations is explored in Section~\ref{sec:featureSupport}, especially Table~\ref{table:rankedFeatureSupport} and Table~\ref{table:unrankedFeatureSupport}.  \label{sec:patternsAreNotRegexes} A particular pattern can specify different regexes in different variants.  For example, the pattern \verb!"a\{2\}"! specifies the regex \cverb!a{2}! in BRE Regular Expressions (which matches the string \verb!"aa"!), but in Python Regular Expressions the same pattern compiles to the regex \cverb!a\{2\}! which matches the string \verb!"a{2}"!.
It is also possible for a pattern to be valid and compile to a regex in one variant, but be invalid in another.  For example the pattern \verb!"^X(?R)?O$"! compiles to a valid regex in Perl 5.10 that uses recursion to require one or more \verb!`X'! characters followed by exactly the same number of \verb!`O'! characters, so that the string \verb!"XXOO"! will match, but \verb!"XXO"! will not match.  Trying to compile this pattern in Python will cause an error.

The difference between regexes and patterns is important primarily when considering portability.  Not all of the patterns used to compile the Python regexes studied in this thesis will necessarily compile to regexes in other languages.  A discussion of what features are supported by different languages is provided in Section~\ref{sec:featureSupport}.

