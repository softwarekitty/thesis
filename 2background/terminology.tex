\section{Terminology}

\subsection{Language nomenclature}
\label{sec:nomenclature}
Regular expression languages are systems for specifying sets of strings.  There are many regular expression language \emph{variants} with substantially different behavior, and so the term \emph{regular expression} can only refer to the topic in general.  An appropriate prefix must always be added in order to differentiate between particular variants (e.g., as used in the sentence:  `Python Regular Expressions can describe a context free language, but Kleene Regular Expressions cannot.').  Note that it is grammatically correct to capitalize these proper nouns because they refer to languages.

Each variant uses several features to specify sets of strings in a compact manner.  A \emph{pattern} is a string that is parsed according to the feature syntax of a variant into units of meaning called \emph{feature tokens}.  For example the pattern \verb!"a*"! is parsed into the \bverb!a! ordinary character token, and the \bverb!*! KLE token.  A valid sequence of feature tokens will always define a set of strings.  This sequence of feature tokens will be called a \emph{regex} (regexes will be the plural form).

Regexes are commonly used to extend keyword search - instead of searching some text for a single keyword, the user can search that text for any string in the set specified by the regex.   An \emph{engine} implements the rules of a variant in order to perform searching, replacing and other functions within a computing environment.  A single variant may have zero or more engines written for it.  An engine \emph{compiles} a pattern into a regex.  The behavior of an engine may be modified by flags or options, as described in Appendix~\ref{app:options}.

\subsection{Matching strings defined}
\label{sec:matchingDefined}
In this thesis it is often necessary to describe the outcome of searching a particular string using a particular regex.  The terminology used is that a regex \emph{matches} a string if that string contains some substring that is equal to a string specified by the regex.  For example, the regex \cverb!abc! matches the entire string \verb!"abc"! but also matches part of \verb!"XabcY"!, and so the regex matches both strings.  This regex does not match \verb!"ab"! because no \verb!`c'! is present.  When considering if a regex matches a string, it is assumed that no flags are modifying the behavior of the engine unless specified in the regex itself.  For ease of expression, a string is said to \emph{match} a regex if that regex matches the string.

This choice of terminology results in the most natural flow of words when discussing the behavior of regexes, but conflicts with the terminology used by several engines.  For example, Java's {\tt java.util.regex.Matcher.matches()} function requires the entire string to match in order to return true.  Also, Python's {\tt re.match()} function requires the beginning of the string to match in order to return a {\tt MatchObject}.  Instead, the definition of \emph{match} used in this thesis is closer to Java's {\tt java.util.regex.Matcher.find()} function and Python's {\tt re.search()} function.  The definition of \emph{match} used in this thesis is useful because, in general, it is a necessary condition (but not always a sufficient condition) for a regex to \emph{match} a string in order for any function provided by any engine to take action based on that match.

\subsection{Patterns are not regexes}
\label{sec:patternsAreNotRegexes}
A particular pattern can specify different regexes in different variants.  For example, the pattern \verb!"a\{2\}"! specifies the regex \cverb!a{2}! in BRE Regular Expressions (which matches the string \verb!"aa"!), but in Python Regular Expressions the same pattern compiles to the regex \cverb!a\{2\}! which matches the string \verb!"a{2}"!.
It is also possible for a pattern to be valid and compile to a regex in one variant, but be invalid in another.  For example the pattern \verb!"^X(?R)?O$"! compiles to a valid regex in Perl 5.10 that uses recursion to require one or more \verb!`X'! characters followed by exactly the same number of \verb!`O'! characters, so that the string \verb!"XXOO"! will match, but \verb!"XXO"! will not match.  Trying to compile this pattern in Python will cause an error.

The difference between regexes and patterns is important primarily when considering portability.  Not all of the patterns used to compile the Python regexes studied in this thesis will necessarily compile to regexes in other languages.  A discussion of what features are supported by different languages is provided in Section~\ref{sec:featureSupport}.

\paragraph{Most patterns compile to a functionally identical regex in most languages}
\label{sec:usuallyOk} Examples have been shown of patterns that can have alternate meanings, or can be compiled by one engine, but not another.  However, it is typical for a pattern using common features to compile to a regex with identical behavior in multiple variants.  The extent of feature overlap among variations is explored in Section~\ref{sec:featureSupport}, especially Table~\ref{table:rankedFeatureSupport} and Table~\ref{table:unrankedFeatureSupport}.
