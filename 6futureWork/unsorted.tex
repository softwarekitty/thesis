
\paragraph{Equivalence Class Models}
This study uses 5 equivalence classes, each with 3 to 5 nodes.  These equivalence classes are very inclusive of regexes with very different behavior, and are defined largely by the features used by a regex.  Future work could look into much more narrowly defined equivalence models, specific to particular behaviors of the most frequently observed regexes.  For example a node could require the presence of a very specific, frequently used CCC like \cverb![a-zA-Z0-9_-]! which can be refactored to \cverb![\w-]!.

In addition to breaking the five equivalence classes into more granular nodes, future work could model refactorings outside of these groups. Due to the functional variety and significant number of features to consider, this work does not provide a list of all possible refactoring groups.  However the following 5 additional equivalence classes are examples of other possible groups:
\begin{description}
\item[Single line option]  \verb!'''(.|\n)+'''! $\equiv$ \verb!(?s)'''(.)+'''!
\item[Multi line option]  \verb!(?m)G\n! $\equiv$ \verb!(?m)G$!
\item[Multi line option]  \verb!(?i)[a-z]! $\equiv$ \verb![A-Za-z]!
\item[Backreferences]  \verb!(X)q\1! $\equiv$ \verb!(?P<name>X)q\g<name>!
\item[Word Boundaries]  \verb!\bZ! $\equiv$ \verb!((?<=\w)(?=\W)|(?<=\W)(?=\w))Z!
\end{description}

Future work could also use reasoning tools for regular expressions, like Microsoft's Automata library to identify populations of equivalent regexes with differing representations, even identifying \emph{all} equivalence classes present in a given corpus.

\paragraph{Regex Programming Standards}
Many organizations enforce coding standards in their repositories to ease understandability.  Using an equivalence class model and the node counting technique described in this chapter could help to objectively develop regular expression standards for a given development community like Mozilla or OpenBSD.

\paragraph{Studying a different corpus}
A technique similar to the one described in this work could be applied to a different corpus.  Ideas about alternative ways to build a corpus of regexes can be found in Section~\ref{sec:alternateCorpus}).  The concept of a community standard would be reinforced by regexes sourced from a very specific community like only text editor projects, or only shopping cart frameworks.





Unable to get enough information about Swift's underlying NSRegularExpression to include it in the table - a strong contender for future work!  Also wanted to get Vim's features but do not have time, and it is a very alien feature set!.


\paragraph{Alternative techniques for building a corpus}
\label{sec:alternateCorpus}
any number of different regular expression languages like Perl Regular Expressions, Java Regular Expressions or .Net Regular Expressions.  Also independent of the regular expression language, the regexes studied could come from a variety of sources like sourceforge, bitbucket, a private repository, or even from github using a different technique than the one used to build the corpus (described in
\todoMid{Mention how exploring character details like literals, hex, octal and supported escape specials like bell, vertical wsp, etc is an opportunity for future work}

\paragraph{Portability Guides}
Similarly in JavaScript and POSIX ERE, the pattern \verb!"a\Z"! compiles to a regex matching the string \verb!"aZ"!, because the sequence \verb!"\Z"! has no special significance and the backslash is ignored.  In Python Regular Expressions, this sequence does have significance - a feature matching the absolute end of the string (after the last newline).  However, in Java, Perl, .Net and many other variants this sequence has a slightly different meaning (absolute end or before last newline).
