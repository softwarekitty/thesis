\section{Discussion of cluster categories}
\subsection{Implications}
When tool designers are considering what features to include, data about usage in practice is valuable.  Behavioral similarity clustering  helps to discern these behaviors by looking beyond the structural details of specific patterns and seeing trends in  matching behavior. We are also able to find out what features are being used in these behavioral trends so that we can make assertions about why certain features are important.
We used the behavior of individual patterns to form clusters, and identified six main categories for the clusters.
 Overall, we see that many clusters are defined by the presence of particular tokens, such as the colon for the cluster in Table~\ref{table:exampleCluster}.
We identified six main categories that define regex behavior at a high level: matching with alternatives, matching literal characters, matching with sequences, matching with endpoint anchors, parsing contents of brackets or braces, or searching and capturing code, and can be considered in conjunction with the self-described regex activities from the survey in Table~\ref{tab:regexactivities} to be representative of common uses for regexes.
One of the six common cluster categories, \emph{Code Search and Variable Capturing}, has a very specific purpose of parsing source code files. This shows a very specific and common use of regular expressions in practice.

\subsubsection{Finding Specific Content}
Two categorical clusters, \emph{Specific Characters Must Match} and \emph{Two or More Characters in Sequence}, deal with identifying the presence of specific character(s).
While multiple character matching subsumes single character matching, the overarching theme is that these regexes are looking to validate strings based on the presence of very specific content, as would be done for many common activities listed in Table~\ref{tab:regexactivities}, such as, ``Locating content within a file or files."
More study is needed into what content is most frequently searched for, but from our cluster analysis we found that version numbers, twitter or user handles, hex values, decimal numbers, capitalized words, and particular combinations of whitespace, slashes and other delimiters were discernible targets.

Capturing the contents of brackets and searching for delimiter characters were some of the most apparent  behavioral themes observed in our regex clusters, and developers frequently use regexes to parse source code.

\todoMid{clean these thoughts}  Previous discussions have been compacted until nearly meaningless, but here is what people are really doing, as revealed by the clustering:
\begin{itemize}
\item parse a line of source code to capture an assignment using `='
\item capture/find/identify/count identifiers like emails, usernames, twitter handles, etc
\item parse some structured file, maybe xml or maybe just something home-rolled that is regular by design
\item similarly, finding a special marker that you are expecting.  For example, if you write a program that inserts a colon between some fields when serializing an object, then you can de-serialize using the colon.  There is so much freedom that it's a hard pattern to detect, but I think this is where the single-character focus comes in the most often.
\item foolishly parse contents of brackets.  This can be okay in certain controlled contexts.
\item similarly foolishly parsing contents of double-quotes.
\item breaking down a log file, maybe counting presence/absence of something or summing a field when present
\item parsing a simple string code like a date format, certainly html escape codes
\item parsing a phone number, ssn, numeric date, regular number
\item absolutely parsing urls. period.  mostly this.  Also IP addresses.  All sorts of web protocols are regular.
\item scanning for keywords using an OR.  This is dubious when it's like password|secret|hash, so someone is fishing...
\item scanning for an expected error message prefix like `Invalid object specification:'
\item scanning for objects and function calls like `prefs.add\(.*\)'
\item scanning for HTML content like `a href='
\item really generic stuff like numbers and then some space...so vanilla it is hard to say what they were doing without going back to their code.
\end{itemize}
%taking break at line 1200


\subsection{Opportunities for future work}
\subsection{Threats to validity}
