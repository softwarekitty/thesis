\subsection{Node counting results}
\label{sec:nodeCountingResults}

\input{table/nodeCount}

For each node, Table~\ref{table:nodeCount} presents the number of regexes belonging to that node, and the number of projects containing at least one such regex belonging to that node. The \emph{Node} column references the node labels (like `T1') in Figure~\ref{fig:refactoringTree}.  The \emph{Description} column briefly describes the rules for node membership, followed by an \emph{Example} regex from the corpus. The \emph{NReg.} column counts the regexes that belong to a given node, followed by the percent of regexes out of 13,597 (the total number of regexes in the corpus). The \emph{NProj.} column counts the projects that contain a regex belonging to the node, followed by the percentage of projects out of 1,544 (the total number of projects scanned that contain at least one regex from the corpus). Recall that the regexes of the corpus are all unique and could appear in multiple projects, hence the project support is used to show how pervasive the node is across the whole community. For example, 2,479 of the regexes belong to the C1 representation, representing 18.2\% of regexes in the corpus. These appear in 810 projects, representing 52.5\%. Regexes belonging to D1 appear in 346 (2.5\%) of the regexes in the corpus, but only 234 (15.2\%) of the projects. In contrast, 39 \emph{fewer} regexes are in node T3, but 34 \emph{more} projects use regexes from T3, indicating that D1 is more concentrated in a few projects and T3 is more widespread across projects.

\subsection{Discussion of refactorings}
\label{sec:equivRefactorings}
Using the count of regexes in each node provided in Table~\ref{table:nodeCount}, the most preferred nodes for each group are C1, D2, T1, L2, and S2.  In this section the practical issues of refactorings strongly indicated by between nodes are explored and several preferences between nodes are identified.

\subsubsection{Community based CCC refactoring}

\paragraph{C1 may be preferred overall because ranges are shorter.}
Within the CCC group, C1 has the most regexes (2,479), suggesting that there may be a preference to write a regex with a range whenever possible.  This makes sense, since a range shortens the regex, and programmers are often trying to make their code as short and efficient as possible.

These three regexes from the corpus belong to C2: \cverb!i[3456]86!, \cverb![Hh][123456]! and \\
\cverb!-py([123]\.[0-9])$!.  The community preference for regexes to use C1 suggests refactorings to \cverb!i[3-6]86!, \cverb![Hh][1-6]! and \cverb!-py([1-3]\.[0-9])$! respectively.

\paragraph{C2 contains few sequential character sets, so it is hard to refactor out of.}
On inspection, most regexes in C2 do not express ranges of characters, but instead express non-continuous sets.  The following regexes (or regex fragments) extracted from the corpus illustrate this point: \cverb![?/:|]+!, \cverb!coding[:=]!, \cverb!([\\"]|[^\ -~])!, \cverb!\?|[-+]?[.\w]+$!.  None of these regexes contain ranges, and so they are not candidates for refactoring to C1.

\paragraph{Refactoring out of C3 is generally awkward.}
On inspection, most regexes in C3 seem to be negating just one or two characters like \cverb![^:]*:! and \cverb!^([^/:]+):!, and in these cases refactoring out of C3 would result in a strange-looking regex.  Refactoring these to C1 exposes an awareness of the charset and uses ranges that often start or end with invisible characters.  For example these two regexes when refactored to C1 (assuming ASCII) would be \cverb![\x00-9;-\x7F]*:! and \cverb!^([\x00-.0-9;-\x7F]+):!. Based on logical reasoning about how to express the negation of a character set without using NCCC, the most notable candidate for refactorings going out of C3 is from C3 to C4, because many NCCC simply represent the negated version of some default character class.  However, according to community standards the preferred representation may be in C3, not C4.  The NCCC \cverb![^a-zA-Z0-9_]!, for example, appears in 8 regexes belonging to C3, and could be refactored to \cverb![\W]! which belongs to C4.

\paragraph{Refactoring out of C4 may be recommended.}
Refactorings going from C4 to C1 are possible for the DEC and WRD default character classes, (i.e., \cverb![\d]! to \cverb![0-9]! and \cverb![\w]! to \cverb![0-9a-zA-Z_]!) and may be recommendable based on the standards of the community observable in Table~\ref{table:nodeCount}.  Similarly refactorings from C4 to C3 are possible for the negative default character classes (i.e., \cverb![\D]! to \cverb![^0-9]! and \cverb![\W]! to \cverb![^0-9a-zA-Z_]!).  Refactorings from C4 to C2 might make sense regarding the WSP default character class (i.e., \cverb![\s]! to \cverb![ \t\r\n\v\f]!), but on inspection most regexes in C2 that are close to this new regex typically omit the \verb!`\v'! and \verb!`\f'! characters, with \verb!`\r'! and \verb!`\n'! also omitted at times.  These are probably not accidental omissions, but likely stem from a familiarity with the problem space being dealt with by the regex (e.g., newlines are not expected, so they are not included in the CCC).

\paragraph{Refactoring from C5 to C2 is always recommended.}
Regexes belonging to C5 are the most proportionally widespread compared to other members of the CCC group, with about as many regexes (245) as there are projects that they appear in (239).  One interpretation of this is that these regexes are not pulled from other projects, but are original compositions in each project.  All of the regexes belonging to C5 could be refactored to C2, which offers a more preferred representation style according to the community.  Three such possible refactorings from the corpus are: \cverb!(a|b)*?c! to \cverb![ab]*?c!, \cverb!:|\*|\?|"|<|>|\\|! to \cverb![:*?"<>\\"]! and
\cverb@^(?:!|&|\\*)$@ to \cverb|^(?:[!&*])$|, respectively.

\subsubsection{Community based DBB refactoring}

\paragraph{D1 to D2 is recommended for small upper bounds.} There are about six times as many regexes in D2 (1,871) than there are in D1 (346).  D3 has only 10 regexes and appears in only 27 projects, so it is not recommended according to community standards.  Refactoring from D1 to D2 is always possible, and always recommended by the community standard.  For example the regex \cverb|^[\n\r]{0,1}| from the corpus belonging to D1 becomes \cverb|^[\n\r]?|.  This is a simple change in syntax because the upper bound is low. Similarly the corpus regex \cverb!(\d{2,3})! becomes \cverb!(\d\d\d?)! when transformed from D1 to D2.

In contrast the corpus regex \cverb!^.{3,20}$! belongs to D1, and can be converted to the equivalent representation in D2: \cverb!^....?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?$!.  This new regex is not as compact and seems ridiculous.  Intuitively, it does not make any sense to recommend a refactoring that explodes a small regex into a huge one.  One reason that D2 may have more community support is that the use case of specifying zero-or-one of something is a very natural idea, and may occur more frequently than the need to specify a particular range using DBB.

\subsubsection{Community based LIT refactoring}

\paragraph{T3 to T1 is always recommended.} It is not surprising that most regex belong to the T1 node, since ordinary characters are necessary for most string specifications.  Regex like \cverb![$][{]\d+:([^}]+)[}]! belong to T3 and seem to be trying to avoid escaping special characters by wrapping them in a CCC.  This regex can be refactored to T1 yielding \cverb!\$\{\d+:([^}]+)\}!, which is recommended due to overwhelming community support of T1.

\paragraph{T2 and T4 may be special cases.} The regex from T4 appearing in the most projects (13) is: \cverb![\041-\176]+:$!.  The character class defined in this regex represents the printable ASCII characters.  This could be refactored to the equivalent \cverb|[!-~]$| in T1, but the original regex may offer more intuition about the size of the range being specified.

Similarly, the most popular regex from T3 \cverb![\x80-\xff]! appears in 81 projects and refers to a range of characters above ASCII.  This representation may offer some useful intuition about the range being specified, so a refactoring to T1 is not recommended at this time.  More study is needed into the readability of this type of range and the alternative using T1.

\paragraph{T4 to T2 is always recommended.}  It is not always possible to use a literal character to specify a character. For characters that cannot be represented directly, a refactoring from T4 to T2 is always recommended.  T2 has more than 34 times as many regexes (479) as T4 (14) and so based on community standards, all of these should be refactored.

\subsubsection{Community based LWB refactoring}
\label{sec:communityL2L3}
\paragraph{L2 to L3 may be recommended.} L2 has 6,017 regexes while L3 has 6,003 and so they are very closely tied in terms of number of regexes.  In terms of projects, L3 has a slight advantage with 1,207 compared to the 1,097 containing some L2 regex.  This indicates a slight preference for L3 over L2, but is not a strong indicator.  Furthermore a refactoring from L2 to L3 requires an additional repeated element in the sequence to be present before the element to which KLE is applied.  For example the regex belonging to L2 \cverb!kk*! has this extra \verb!`k'! that can be used to transform this regex into a regex belonging to L3: \cverb!k+!.  However the regex \cverb!k*! does not have another \verb!`k'!, so no transformation is possible.  Patterns of the 6,017 regexes belonging to L3 were searched using the regex \cverb!([^\\)\]])\1\*!, locating 38 patterns where their corresponding regexes could be transformed this way.  The most popular example (8 projects) was the regex \cverb!(?::*)! which would become \cverb!(?:+)!.

\paragraph{L1 to L3 is recommended for lower bounds.}  L1 has only 91 regexes or almost 67 times fewer than L3, so the community supports a refactoring to L3.  The most popular regex in L1 (32 projects) is \cverb!\n{2,}! which can be transformed to \cverb!\n\n+! belonging to L3.  The regex in L1 with the largest lower bound is \cverb![1-9A-HJ-NP-Za-km-z]{26,}\\Z! which when transformed to a regex in L3 would become too long to typeset in this thesis, and that refactoring cannot be recommended.  However only 3 regexes had a lower bound greater than 6 and only 10 had a lower bound greater than 4, so most regexes in L1 are good candidates for refactoring to L3.

\subsubsection{Community based SNG refactoring}
\paragraph{Refactoring to S2 may be recommended for small repetitions.}  Inspecting the contents of S2 reveals that most of these regexes belong to S2 because they contain normal words like \verb!"session"! or \verb!"https"! that happen to have a repetition of characters.  Considering how common english words with double letters are, including regexes with double letter words as part of S2, as is done in this analysis, over-estimates the real number of semantically equivalent regexes for which a refactoring is reasonable.  Transforming regexes using S1 on ordinary characters, like \cverb!lit{2}le fo{2}t! to double letters like \cverb!little foot! can be recommended from the data.  However, for other types of refactoring, a side-effect of including double letters in S2 is an over-estimation of the community support for refactoring into S2 for regexes that are not dealing with repeating letters in words.  For example, consider the most popular (32 projects) regex from S1: \cverb!^[a-f0-9]{40}$!.  Expanding this out so that it uses sequential repetition would create a very long regex and cannot be recommended.  However transforming the regex \cverb!^(-?\d+)(\d{3})! from S1 yields the regex \cverb!^(-?\d+)(\d\d\d)! which may be recommended by the community standards, but more investigation is needed.  One suggestion is to create a separate equivalence class dealing with S2-type repetition of ordinary characters, dealing with other elements separately.

\paragraph{Refactoring out of S3 is recommended.}
S3 only has 27 regexes, and all of them seem to be abusing the DBB feature by making the upper and lower bounds identical.  Perhaps these regexes started off with different bounds and were fixed as time went on to have identical bounds.  Due to the large segment of S2 based on double letters in words, it is not clear whether to recommend a refactoring to S1 or S2.  Perhaps the best recommendation is to refactor low numbers of repetitions of small elements to S2, and all others to S1.

\subsection{Threats to validity}
The technique of determining the number of regexes in each node includes manual verification, so it may overcount or undercount node membership.  This does not represent a serious threat, however, because a small number of errors would not significantly change the main results of the work.
The rules used to define the nodes of equivalence classes were very simple, and may not have been sophisticated enough to consider all the nuances of real usage.  For example, additional rules could have been applied to split the SNG equivalence class into one class dealing with SNG-type repetition applied exclusively to ordinary characters, and one class not dealing with ordinary characters.  Hypothetically, opposite refactorings could be preferred in these two groups.  By merging them, the refactoring preferences would interfere and no preference would be detected. As the first work on regular expression refactoring, this outcome is not unexpected.  Other equivalence classes are considered in Section~\ref{dis:equivalenceModels}.

Since the corpus is randomly selected from GitHub the projects it references may be biased towards homeworks and small pet projects, or frequently cloned projects like the linux kernel.  This threat is not of significant concern.
