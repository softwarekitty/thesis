\section{Node counting results}

\input{table/nodeCount}

For each node, Table~\ref{table:nodeCount} presents the number of regexes belonging to that node, and the number of projects containing at least one such regex belonging to that node. The \emph{node} column references the node labels (like `T1') in Figure~\ref{fig:refactoringTree}.  The \emph{description} column briefly describes the rules for node membership, followed by an \emph{example} regex from the corpus. The \emph{nRegexes} column counts the regexes that belong to a given node, followed by the percent of regexes out of 13,597 (the total number of regexes in the corpus). The \emph{nProjects} column counts the projects that contain a regex belonging to the node, followed by the percentage of projects out of 1,544 (the total number of projects scanned that contain at least one regex from the corpus). Recall that the regexes of the corpus are all unique and could appear in multiple projects, hence the project support is used to show how pervasive the node is across the whole community. For example, 2,479 of the regexes belong to the C1 representation, representing 18.2\% of regexes in the corpus. These appear in 810 projects, representing 52.5\%. Regexes belonging to D1 appear in 346 (2.5\%) of the regexes in the corpus, but only 234 (15.2\%) of the projects. In contrast, 39 \emph{fewer} regexes are in node T3, but 34 \emph{more} projects use regexes from T3, indicating that D1 is more concentrated in a few projects and T3 is more widespread across projects.

\section{Discussion}

\subsection{Preferences indicated by community support}
Using the count of regexes in each node provided in Table~\ref{table:nodeCount}, the most preferred nodes for each group are C1, D2, T1, L2, and S2.  In this section the practical issues of refactoring between nodes are explored and several preferences between nodes are identified.

\subsubsection{CCC refactoring issues}

\paragraph{C1 may be preferred overall because ranges are shorter}
Within the CCC group, C1 has the most regexes (2,479), suggesting that there may be a preference to write a regex with a range whenever possible.  This makes sense, since a range shortens the regex, and programmers are often trying to make their code as short and efficient as possible.

These three regexes from the corpus belong to C2: \cverb!i[3456]86!, \cverb![Hh][123456]! and \\
\cverb!-py([123]\\.[0-9])$!.  The community preference for regexes to use C1 suggests refactorings to \cverb!i[3-6]86!, \cverb![Hh][1-6]! and \cverb!-py([1-3]\\.[0-9])$! respectively.

\paragraph{C2 contains few sequential character sets, so it is hard to refactor out of}
On inspection, there are very few such regexes in C2 that are obvious candidates for refactoring to C1.  This is true because most of regexes in C2 do not express ranges of characters, but instead express non-continuous sets.  The following regexes (or regex fragments) extracted from the corpus illustrate this point: \cverb![?/:|]+!, \cverb!coding[:=]!, \cverb!([\\\\"]|[^\\ -~])!, \cverb!^[012TF\\*]{9}$!, \cverb!\\?|[-+]?[.\\w]+$!.

\paragraph{Refactoring out of C3 is generally awkward}
Similarly, very few regexes in C3 actually seem like candidates for refactoring to C1 on inspection.  Although the transformation is possible, most regexes in C3 seem to be negating just one or two characters like \cverb![^:]*:! and \cverb!^([^/:]+):!.  Refactoring these to C1 exposes an awareness of the charset and uses ranges that often start or end with invisible characters.  For example these two regexes when refactored to C1 (assuming ASCII) would be \cverb![\x00-9;-\x7F]*:! and \cverb!^([\x00-.0-9;-\x7F]+):!. The most notable candidate for refactorings going out of C3 is probably from C3 to C4, because many NCCC simply represent the negated version of some default character class.  For example the NCCC \cverb![^a-zA-Z0-9_]! appears in 8 regexes belonging to C3, and could be refactored to \cverb![\W]! which belongs to C4.  However, according to community standards the preferred representation may be in C3, not C4.

\paragraph{Refactoring out of C4 may be recommended}
Refactorings going from C4 to C1 are possible for the DEC and WRD default character classes, (i.e., \cverb![\d]! to \cverb![0-9]! and \cverb![\w]! to \cverb![0-9a-zA-Z_]!) and may be recommendable based on the standards of the community observable in Table~\ref{table:nodeCount}.  Similarly refactorings from C4 to C3 are possible for the negative default character classes (i.e., \cverb![\D]! to \cverb![^0-9]! and \cverb![\W]! to \cverb![^0-9a-zA-Z_]!).  Refactorings from C4 to C2 might make sense regarding the WSP default character class (i.e., \cverb![\s]! to \cverb![ \t\r\n\v\f]!), but on inspection most regexes in C2 that are close to this new regex typically omit the \verb!`\v'! and \verb!`\f'! characters, with \verb!`\r'! and \verb!`\n'! also omitted at times.

\paragraph{Refactoring from C5 to C2 is always recommended}
Regexes belonging to C5 are the most proportionally widespread compared to other members of the CCC group, with about as many regexes (245) as there are projects that they appear in (239).  One interpretation of this is that these regexes are not pulled from other projects, but are original compositions in each project.  All of the regexes belonging to C5 could be refactored to C2, which offers a more preferred representation style according to the community.  Three such possible refactorings from the corpus are: \cverb!(a|b)*?c! to \cverb![ab]*?c!, \cverb!:|\*|\?|"|<|>|\\|! to \cverb![:*?"<>\\"]! and
\cverb@^(?:!|&|\\*)$@ to \cverb|^(?:[!&*])$|.


\subsubsection{DBB preferences}

 With one exception, these are the same for recommendations based on projects. The difference is that L3 appears in more projects than L2, so it is not clear which is more desirable based on community standards.

\paragraph{Regex Programming Standards}
Many organizations enforce coding standards in their repositories to ease understandability.  An organization could develop standards based on how frequently regexes of the same type appear.

\subsubsection{Other insights gained from the node count}



\subsection{Opportunities for future work}

\paragraph{Equivalence Class Models}
This study uses 5 equivalence classes, each with 3 to 5 nodes.  These equivalence classes are very inclusive of regexes with very different behavior, and are defined largely by the features used by a regex.  Future work could look into much more narrowly defined equivalence models, specific to particular behaviors of the most frequently observed regexes.  For example a node could require the presence of a very specific, frequently used CCC like \cverb![a-zA-Z0-9_-]! which can be refactored to \cverb![\w-]!.

In addition to breaking the five equivalence classes into more specific nodes, future work could model refactorings outside of these groups.  This work does not provide a list of all possible refactoring groups given the functional variety and significant number of features to consider, but does provide a few additional equivalence classes outside of our 5 groups:
\begin{description}
\item[Single line option]  \verb!'''(.|\n)+'''! $\equiv$ \verb!(?s)'''(.)+'''!
\item[Multi line option]  \verb!(?m)G\n! $\equiv$ \verb!(?m)G$!
\item[Multi line option]  \verb!(?i)[a-z]! $\equiv$ \verb![A-Za-z]!
\item[Backreferences]  \verb!(X)q\1! $\equiv$ \verb!(?P<name>X)q\g<name>!
\item[Word Boundaries]  \verb!\bZ! $\equiv$ \verb!((?<=\w)(?=\W)|(?<=\W)(?=\w))Z!
\end{description}

Future work could also use reasoning tools for regular expressions, like Microsoft's Automata library to identify populations of equivalent regexes with differing representations, even identifying \emph{all} equivalence classes present in a given corpus.

\paragraph{Studying a different corpus}

using larger sets of regexes from other languages and sources,
targeting specific communities

\subsection{Threats to validity}
human error in manual validation
overly general rules defining nodes may obscure better refactorings
our corpus is randomly selected from github, may be biased towards homeworks and small pet projects, or frequently cloned projects like the linux kernel
community may support smelly nodes through ignorance
