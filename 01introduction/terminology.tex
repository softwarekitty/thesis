\section{Terminology used in this thesis}

\todoMid{clean this thought}
Let's clear up the confusion about whether regular expressions are equiv with regular languages - not since 1973?, when back-references were included, so we can have the regex \verb!`(ab*)\1'! which cannot be defined by any finite automata (think pumping lemma) and is therefore not a regular language, but is a context-free language and can be recognized by a push-down automata.  Furthermore, the regex \verb!`(ab*)\1\1'! cannot be defined by any push-down automata and is therefore a context-sensitive language\footurl{http://stackoverflow.com/questions/11101405/how-do-backreferences-in-regexes-make-backtracking-required}.  And while we're on this topic, we should cover languages like $\{<div>^n</div>^n\| n\geq0\}$ which require balanced tags, parenthesis or similar - these cannot be represented with the regex features analyzed in this thesis, but may be described using Perl 5.10 recursion.

To understand how programmers use regular expressions in Python projects, we scraped \dbfetch{nProjScanned} Python projects from GitHub, and recorded regex usages for analysis. Throughout the rest of this paper, we  employ the following terminology:\\

% \noindent \textbf{Utilization}: A \emph{utilization} occurs whenever a regex appears in source code.  We detect utilizations by statically analyzing source code and recording calls to the {\tt re} module in Python.
% Within a source code file, a {utilization} is composed of a function, a pattern, and 0 or more flags.  Figure~\ref{fig:exampleUsage} presents an example of one regex {utilization}, with key components labeled. The function call is {\tt re.compile}, \verb!(0|-?[1-9][0-9]*)$! is the regex string, or pattern, and {\tt re.MULTILINE} is an (optional) flag. When executed, this {utilization}  will compile a regex object in the variable {\tt r1} from the pattern \verb!(0|-?[1-9][0-9]*)$!, with the \verb!$! token matching at the end of each line because of the {\tt re.MULTILINE} flag. Thought of another way, a regex  utilization is one single invocation of the {\tt re} library.\\

% \begin{figure}[tb]
% \centering
% \includegraphics[width=\columnwidth]{nontex/illustrations/exampleUsage.eps}
% \vspace{-12pt}
% \caption{Example of one regex utilization}
% \vspace{-6pt}
% \label{fig:exampleUsage}
% \end{figure}

% \noindent \textbf{Pattern}: A \emph{pattern} is extracted from a utilization, as shown in Figure~\ref{fig:exampleUsage}. In essence, it is a string, but more formally it is an ordered series of regular expression language feature tokens.  The pattern in Figure~\ref{fig:exampleUsage}  will match if it finds a zero at the end of a line, or a (possibly negative) integer at the end of a line (i.e., due to the {\tt -?} sequence denoting zero or one instance of the {\tt -}).

% Note that because the vast majority of regex features are shared across most general programming languages (e.g., Java, C, C\#, or Ruby), a Python {pattern} will (almost always) behave the same when used in other languages, whereas a utilization is not universal in the same way (i.e., it may not compile in other languages, even with small modifications to function and flag names).
% As an example, the {\tt re.MULTILINE} flag, or similar, is present in Python, Java, and C\#, but  the Python {\tt re.DOTALL} flag is not present in C\# though it has an equivalent flag in Java.

% In this work, we primarily focus on patterns since they are cross-cutting across languages and are the primary way of specifying the matching behavior. Next, we describe the research questions, data set collection and analysis.

% We consider regex language features to be tokens that specify the matching behavior of a regex pattern, for example,  the {\tt +} in {\tt ab+}.  All studied features are listed and described in Table~\ref{table:featureStats} with examples. We then map the feature coverage for four common regex support tools, brics, hampi, RE2 and Rex, and explore survey responses regarding feature usage for some of the less supported features.\\

% Regular expressions (regexes) are an abstraction of keyword search that enables the identification of text using a pattern instead of an exact keyword.  For example, the pattern \verb!`ab*c'! will match strings beginning with a, followed by zero or more b's, and ending in c, such as: `ac'!, `abc', `abbc', etc.

% Regexes are commonly used for parsing text using a general purpose language like Python, validating content entered into web forms using JavaScript, and searching text files for a particular pattern using tools like grep, vim or Eclipse.

% Although regexes are powerful and versatile, they can be hard to understand,  maintain, and debug, resulting in tens of thousands of bug reports~\cite{Spishak:2012:TSR:2318202.2318207}.

% Regular expressions are used frequently by developers for many purposes, such as parsing files, validating user input, or querying a database.
% Regexes are also employed in MySQL injection prevention~\cite{Yeole:2011:ADT:1980022.1980229} and network intrusion detection~\cite{network}.
% However, recent research has suggested that regular expressions (regexes) are hard to understand, hard to compose, and error prone~\cite{Spishak:2012:TSR:2318202.2318207}.
% Given the difficulties with working with regular expressions and how often they appear in software projects and processes, it seems fitting that efforts should be made to ease the burden on developers.





