\section{Feature Support}

\paragraph{High-level focus} Different regex analysis tools and engines support different features, and the variation among the supported feature set is not easy to define.  Often the same feature is essentially supported, but nuances exist so that the exact behavior of the feature still varies enough to have an effect on code that relies on regexes using that feature.

As an example, the {\tt re.MULTILINE} flag, or similar, is present in Python, Java, and C\#, but  the Python {\tt re.DOTALL} flag is not present in C\# though Java has an equivalent flag.

Documentation of engines varies in detail and quality, so that often the particular behavioral details and full feature set is only known to developers of the engine.  In this attempt to document some of the variations in feature support, no attempt is made to address these minor nuances and tricky details, but instead the focus is on documenting the presence or absence of features at a high level.

\todoMid{moved the analysis of features here, clean and prune later}
The next four columns, (i.e., \emph{brics}, \emph{hampi}, \emph{Rex}, and \emph{RE2}), map to the four major research projects chosen for our investigation.  We indicate that a project supports a feature with the `\yes' symbol, and indicate that a project does not support the feature with the `\no' symbol.

\subsubsection{Feature Support in Regex Tools}
While there are many regex tools available, in this work, we focus on the feature support for  four tools, brics, hampi, Rex and RE2, which offer diversity across developers (i.e., Microsoft, Google, open source, and academia) and applications. Further, as we wanted to perform a feature analysis, these four tools and their features are well-documented, allowing for easy comparison.

To create the tool mappings, we consulted documentation for each tool. For brics, we collected the set of supported features using the formal grammar\footurl{http://www.brics.dk/automaton/doc/index.html?dk/brics/automaton/RegExp.html}.  For hampi, we manually inspected the set of regexes included in the {\tt lib/regex-hampi/sampleRegex} file within the hampi repository\footurl{https://code.google.com/p/hampi/downloads/list} (this may have been an overestimation, as this included more features than specified by the formal grammar\footurl{http://people.csail.mit.edu/akiezun/hampi/Grammar.html}).  For RE2, we used the  supported feature documentation\footurl{https://re2.googlecode.com/hg/doc/syntax.html}.  For Rex, we collected the feature set empirically because we tried to parse all scraped patterns with Rex for the behavioral analysis
, and Rex provides comprehensive error feedback for unsupported features.

Of the four projects selected for this analysis, RE2 supports the most studied features (28 features) followed by hampi (25 features),  Rex (21 features), and brics (12 features).  All projects support the 8 most commonly used features except brics, which does not support STR or END.

No projects support the four look-around features LKA, NLKA, LKB and NLKB.  RE2 and hampi support the LZY, NCG, PNG and OPT features, whereas brics and Rex do not.

\subsection{Variation in feature sets among Analysis tools}

\paragraph{Rationale for exploring features supported by Analysis tools} \todoMid{Some paragraph introducing this table}

\input{table/featureVariationTools}

\subsection{Variation in feature sets among languages}
\label{sec:featureSupport}

\paragraph{Rationale for exploring features supported by different languages} \todoMid{Some paragraph introducing this table}

Note: we exclude substitutions like \$n, only valid in a replacement context.  Also if a feature has the same functionality but different syntax...it is NOT considered the same feature, considering the desire to port patterns across languages, for example \cverb!\Z! in Python is \cverb!\z! in most other variants, and in those variants \cverb!\Z! means something else!  One exception is the OPT feature, for which different engines have different sets of options.  Python's set of 7 options is small compared to Tcl which has 15 or so.  For the feature table, if the following 3 core options are supported: \cverb!(?ism)!, the variant will be shown as having that feature.

Unable to get enough information about Swift's underlying NSRegularExpression to include it in the table - a strong contender for future work!  Also wanted to get Vim's features but do not have time, and it is a very alien feature set!.

% \input{table/featureVariationLanguages}
\input{table/rankedFeatureSupport}

% \subsection{Brief description of Alien features}
% This thesis provides detailed descriptions for many Python Regular Expression features in Section~\ref{sec:featureDescriptions}.  The features alien to our main explorations are not described in detail, but are present in Table~\ref{featureVariationLanguages}.  Only an example of the syntax and a reference code is provided in this table, but a cursory description of them by reference code is provided below.
Python\footurl{https://docs.python.org/2/library/re.html}
Java\footurl{https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html}
Automata.Z3\footurl{https://github.com/AutomataDotNet/Automata/blob/master/src/Automata.Tests/SampleRegexes.cs}
PCREvsPython\footurl{http://stackoverflow.com/questions/3070655/does-regex-differ-from-php-to-python}
.Net\footurl{http://regexhero.net/reference/}
POSIX.ERE\footurl{http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html},
\footurl{http://www.regextester.com/eregsyntax.html}
%#tag_09_04
Perl\footurl{https://www.cs.tut.fi/~jkorpela/perl/regexp.html}
Swift\footurl{https://www.raywenderlich.com/86205/nsregularexpression-swift-tutorial}
Javascript\footurl{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions},\footurl{http://www.ecma-international.org/ecma-262/5.1/}
%#sec-15.10
- note that javascript is an implementation of the ecma standard, including r.e. support.
RE2\footurl{https://github.com/google/re2/wiki/Syntax}
VIM\footurl{http://vimregex.com/}

\input{table/alienFeatureSupport}

\begin{description} \itemsep -1pt
\item [FTR1] does something \todoMid{finish descriptions for posterity}
\end{description}

\todoMid{merge these thoughts into this section somewhere}
Similarly in JavaScript and POSIX ERE, the pattern \verb!"a\Z"! compiles to a regex matching the string \verb!"aZ"!, because the sequence \verb!"\Z"! has no special significance and the backslash is ignored.  In Python Regular Expressions, this sequence does have significance - a feature matching the absolute end of the string (after the last newline).  However, in Java, Perl, .Net and many other variants this sequence has a slightly different meaning (absolute end or before last newline).

LNLZ specifies the position before the final newline in a string, even in Multiline mode.  In Python ENDZ specifies the absolute end of the string.

Third, we investigate what features are supported by four large projects that aim to support regex usage (brics~\cite{brics}, hampi~\cite{hampi}, Rex~\cite{rex}, and RE2~\cite{re2}), and which features are not supported, but are frequently used by developers.

\todoMid{Mention how exploring character details like literals, hex, octal and supported escape specials like bell, vertical wsp, etc is an opportunity for future work}
One notable omission from Table~\ref{table:featureStats} is the literal feature, which is used  to specify matching any specific character.  An example pattern that contains only one literal token is the pattern \verb!`a'!.  This pattern only matches the lowercase letter `a'.  The literal feature was found in \dbfetch{P_LITERAL_PRESENT}\% of patterns.

